\chapter{Visões (II)}\label{cap:visoes2}

\begin{objectivos}
\item Exercitar o uso de estruturas de dasdos e mecanismos de controlo para objectos bidimensionais
\item Introduzir conceitos básicos sobre processamento de imagens digitais 
\item  Introduzir o módulo cImage
\item Exercitar ao uso de funções como parâmetros
\end{objectivos}

\section{Introdução}

Vivemos num mundo cada vez mais dominado pelas imagens. A manipula\c cão das imagens permite-nos criar uma nova realidade e explorar novas combina\c cões de formas e de cores. Com os computadores essa possibilidade de altera\c cão e de jogo foi potenciada a uma escala nunca antes vista. Hoje, existem imensos programas que nos permitem exercitar a nossa imagina\c cão artística, de que o \textbf{Photoshop} da Adobe é apenas um exemplo. Neste capítulo iremos ver como podemos nós próprios usar e transformar imagens, por recurso à linguagem \textbf{Python}. Mas comecemos por clarificar o que são  imagens e como podem ser guardadas num computador. De um modo informal uma imagem é uma estrutura bidimensional, uma matriz de pontos, cada um deles designado por \textbf{pixel}\footnote{Acrónimo derivado do inglês \textit{picture element}.}. Uma representação comum das imagens em computador consiste em representar cada pixel separadamente, falando-se então em imagens \textit{bitmap}\footnote{Uma alternativa designa-se por imagens \textbf{vectoriais}. De um modo grosseiro, isso significa que em vez da imagem o que é guardado e manipulado é o programa que produz a imagem.}. Cada pixel, por sua vez, é codificado de acordo com um dado \textbf{modelo}. No caso do modelo \textbf{RGB},  a cor é decomposta em três componentes, ou \textbf{canais}\footnote{É possível a existência de mais canais, como seja o canal \textbf{alfa} para a transparência.}, uma para Vermelho (\textit{Red}), outro para Verde (\textit{Green}), e outro para azul (\textit{Blue}), à semelhança do modo como nós humanos percebemos a cor. Cada canal é representado por um byte, o que significa que um pixel ocupa 3 bytes (24 bits) e podemos representar em teoria $256^3 = 16777216$ cores diferentes, visto cada canal poder assumir$2^8 = 256$ valores diferentes\footnote{Outros modelos de cor são o HSB e o CMYK, este último usado pelas impressoras.}. \\


A figura \ref{fig:cores} mostra algumas cores e respectivas codificações RGB.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.6]{visoes_2/imagens/cores.jpg}
\caption{Mapeamento RGB cores}
\label{fig:cores}
\end{center}
\end{figure}

Na última linha da figura apresentamos diversos níveis de cinzento, que se obtém usando o mesmo valor para os três canais. No caso extremo temos a cor branca (255 em cada canal) e a cor preta (0 em cada canal).\\

As imagens ocupam muito espaço. A tabela \ref{tab:pix} mostra alguns valores, isto é, o espaço ocupado para diferentes \textbf{resoluções} das imagens.

\begin{table}[htdp]
\caption{Imagens e tamanhos}
\begin{center}
\begin{tabular}{|c|c|c|c|}\hline
& 320 $\times$ 240 & 640 $\times$ 480 & 1024 $\times$ 768\\ \hline \hline
24-bits cor & 230400 bytes&921600 bytes&2359296 bytes  \\ \hline
\end{tabular}
\end{center}
\label{tab:pix}
\end{table}%


É pois com naturalidade que se procuraram métodos de compressão de imagem. Existem vários métodos de compressão, como é o caso da norma JPEG\footnote{Acrónimo derivado do inglês \textit{Joint Photographic Experts Group}},  que especifica o modo como uma imagem é transformada numa sequência de bytes e o processo inverso. Tipicamente perde-se alguma informação durante a compressão/descompressão, mas nalgumas situações essa perda de qualidade é aceitável\footnote{Em certas aplicações, e.g., na área médica, essa perda de qualidade não pode ser tolerada.}. Existem algoritmos que tornam possível comprimir a imagem sem perda de informação, como acontece com a técnica conhecida por RLE\footnote{Do inglês \textit{run lenght encoding}.}. Existem vários outros formatos de imagem, nomeadamente os que não provocam perdas como sejam o TIFF, GIF ou PNG.


\section{Representação de imagens}

A manipulação de imagens num computador envolve em geral a sua transferência de um ficheiro em disco para a memória interna. É preciso por isso encontrar uma boa representação, isto é um contentor. Do que já conhecemos de \python e da natureza das imagens \textit{bitmap}, não nos surpreende que uma representação escolhida simples seja uma lista de listas, uma matriz. Cada lista interior representa uma \textbf{linha} da matriz. Por exemplo:\\

$>>>$ matriz = [[1,2,3],[4,5,6],[7,8,9]]\\

No caso das imagens os elementos primitivos não serão números mas (a representação de) pixeis. No modelo RGB um modo simples de representar um pixel é através de um tuplo com o valor das três componentes, ou canais. Estes valores podem variar entre 0 e 255. Um exemplo de uma pequena imagem de 3 por 2 pixeis podia ser:\\


imagem = [[(131, 27, 223), (4, 243, 68), (195, 107, 123)], [(246, 205, 141), (154, 60, 154), (40, 31, 223)]]\\



Resolvida a questão da representação, passemos a alguns exemplos simples de manipulação\footnote{Os exemplos que se seguem envolvem listas de listas de números. Adiante usaremos o que aprendemos para o tratamento de imagens.}. Para começar, vamos ver como podemos visualizar os elementos de uma matriz quadrada qualquer.  A questão essencial que temos que ter em conta é que, havendo duas dimensões, temos que criar \textbf{dois} ciclos, cada um deles responsável por percorrer de modo ordenado cada uma das \textbf{dimensões}. Vejamos o caso mais simples, ou seja, mostrar todos os elementos, por linhas.

\begin{lstlisting}
def mostra_por_linhas(matriz):
	"""Indexação pelo conteúdo."""
	for linha in matriz:
		for coluna in linha:
			print("%5d" % coluna, end=' ')
		print()

def mostra_por_linhas_b(matriz):
	"""Indexação pela posição."""
	for pos_linha in range(len(matriz)):
		for pos_coluna in range(len(matriz[0])):
			print("%5d" % matriz[pos_linha][pos_coluna], end ='')
		print()
\end{lstlisting}


O que têm estes dois programas de diferente? O simples facto de, no primeiro, percorremos a matriz usando o seu conteúdo, enquanto que, no segundo, usamos as posições. E de comum, que pontos devem ser salientados? Essencialmente o modo como fazemos a impressão: o comando \textbf{print}  usa uma marca de formatação (\textbf{\%5d}) e termina com  \textbf{end =''}. É este último facto que permite colocar os elementos de uma linha todos ao lado uns dos outros. O segundo \textbf{print} sem argumento serve apenas para mudar de linha.

Admitamos agora que queremos mostrar a matriz por colunas e não por linhas.

\begin{lstlisting}
def mostra_por_colunas(matriz):
	"""  Indexação pelo posição."""
	for pos_coluna in range(len(matriz[0])):
		for pos_linha in range(len(matriz)):
			print("%3d" % matriz[pos_linha][pos_coluna], end='')
		print()
\end{lstlisting}


Bastou \textbf{trocar} a ordem dos ciclos: o primeiro, trata das colunas, enquanto o segundo, mais interior, trata das linhas! E se forem as matrizes triangulares superior?


\begin{lstlisting}
def mostra_tri_sup(matriz):
	"""Matriz triangular superior.Indexação pela posição."""
	for pos_linha in range(len(matriz)):
		print(' '* 4 * pos_linha,end='') 
		for pos_coluna in range(pos_linha,len(matriz[0])):
			print("%4d" % matriz[pos_linha][pos_coluna],end='')
		print()

\end{lstlisting}


Atente-se como tratamos de mostrar de modo conveniente usando uma expressão de formatação apropriada. Uma vez mais o comando \textbf{print} é essencial para esse objectivo. 

\begin{comment}
Terminamos os exemplos de consulta com o caso da matriz diagonal.

\begin{lstlisting}
def mostra_diag_principal(matriz):
	""" Mostra diagonal principal."""
	for pos_linha in range(len(matriz)):
		print(' '* 3 * pos_linha,end='')
		for pos_coluna in range(0,pos_linha+1):
			if pos_linha == pos_coluna:
				print("%2d" % matriz[pos_linha][pos_coluna])
\end{lstlisting}
\end{comment}

Deixamos ao leitor a tarefa de testar estes programas. \\
Passemos ao problema não de visualizar mas de \textbf{criar} uma matriz conhecida a sua dimensão. Uma solução banal será:

\begin{lstlisting}
def cria_mat(n,m,val):
	"""Cria uma matrix nXm sendo que todos os elementos são iguais a val."""
	mat = []
	for j in range(n):
		linha = []
		for i in range(m):
			linha.append(val)
		mat.append(linha)
	return mat
\end{lstlisting}

Mas com o que já sabemos de \python podemos fazer melhor.

\begin{lstlisting}
def cria_mat_b(n,m,val):
	"""Cria uma matrix nXm sendo que todos os elementos são iguais a val."""
	mat = [[val for i in range(m)] for j in range(n)]
	return mat
	
def cria_mat_c(n,m,val):
	"""Cria uma matrix nXm sendo que todos os elementos são iguais a val."""
	return[[val] * m] * n
\end{lstlisting}

A primeira alternativa baseia-se em listas por compreensão, enquanto que a última no operador de repetição para listas. O recurso a dois ciclos imbricados explícitos é um \textbf{padrão} que pode ser usado em muitas situações. \\

São várias as operações que podemos fazer com matrizes e que nos obrigam a percorrer os seus elementos de acordo com uma determinada ordem. O exemplo mais simples é talvez o da soma de duas matrizes. O programa que se segue pressupõe que as matrizes têm a mesma dimensão.

\begin{lstlisting}
def soma_matriz(mat_1,mat_2):
	""" Soma duas matrizes da mesma dimensão."""
	n_linhas = len(mat_1)
	n_colunas = len(mat_1[0])
	mat = cria_mat(n_linhas,n_colunas,0)
	# Soma
	for i in range(n_linhas):
		for j in range(n_colunas):
			mat[i][j]= mat_1[i][j]+ mat_2[i][j]
	return mat
\end{lstlisting}

Do mesmo modo podemos efectuar a multiplicação de duas matrizes $C = A \times B$, sabendo que:\\

\[ c_{ij} = \sum_{k=1}^n a_{ik} * b_{kj} \]


\begin{lstlisting}
def mult_matriz(mat_1,mat_2):
	"""Multiplica duas matrizes iXk e kXj."""
	n_linhas_1 = len(mat_1)
	n_colunas_1 = len(mat_1[0]) # igual a n_linhas_2
	n_colunas_2 = len(mat_2[0])
	mat_prod = cria_mat(n_linhas_1,n_colunas_2,0)
	# Multiplica
	for i in range(n_linhas_1):
		for j in range(n_colunas_2):
			val=0
			for k in range(n_colunas_1):
				val = val + mat_1[i][k]* mat_2[k][j]
			mat_prod[i][j]=val
	return mat_prod
\end{lstlisting}

Em qualquer destes casos criámos uma matriz  onde depois guardamos o resultado da operação. Mas podemos ter operações em que isso não é um requisito e portanto o resultado da operação resulta na alteração de uma das matrizes.  Suponhamos que queremos modificar uma matriz alterando o seu conteúdo, por exemplo somando uma dada constante a todos os elementos nas posições ímpares.

\begin{lstlisting}
def prod_const_mat(mat,val):
	"""Multiplica os elementos nas colunas ímpares por val."""
	n_linhas = len(mat)
	n_colunas = len(mat[0])
	for linha in range(n_linhas):
		for col in range(1,n_colunas,2):
			mat[linha][col] *= val
	return mat
\end{lstlisting}

Todos estes exemplos mostram a importância fundamental dos dois ciclos \texttt{for} imbricados para percorrer a estrutura bi-dimensional, no interior dos quais se encontra a função de manipulação. Em alguns casos precisamos de criar uma matriz nova, com a dimensão necessária para guardar o resultado da manipulação. Todos estes elementos estarão presentes nos programas de manipulação de imagens que são estruturas a duas dimensões.

\section{O módulo cImage}

Regressemos às imagens e ao problema da sua construção, consulta e manipulação.  Vamos utilizar o módulo \texttt{cImage}\footnote{TBD:...colocar informação sobre o modo de obter...} que disponibiliza uma interface  de alto nível para tratamento de imagens. Este módulo socorre-se de outros dois: o módulo nativo \texttt{Tkinter} e o módulo \texttt{PIL}\footnote{Acrónimo de \textit{Python Imaging Library}. Pode ser obtido em \url{http://www.pythonware.com}.}. Enquanto o \texttt{Tkinter} nos permite definir uma Interface de Utilizador Gráfica\footnote{Em inglês \textit{Grapgical User Interface} (GUI).}, com o \textbf{PIL} podemos manipular imagens de diferentes formatos, como seja jpeg, eps, gif, png, ou tiff, só para mencionar alguns.  Para poder funcionar o PIL socorre-se de um processo de codificação/descodificação mais ou menos complexo, ew cuja descrição sai fora do âmbito deste livro.. No momento em que escrevemos, o módulo PIL derivou em \textbf{Pillow}\footnote{Mais informações sobre o módulo em \url{https://pypi.python.org/pypi/Pillow/2.0.0}.} o que permite ser compatível com a versão 3 da linguagem. Estes módulos dependem ainda de um conjunto importante de bibliotecas para os diversos \textit{codecs} necessários e que devem estar (ou ser) instalados no computador.\\

O módulo permite criar, consultar e manipular três grandes tipos de objectos: janelas, imagens e pixeis. As janelas funcionam como contentores para as imagens, enquanto estas são formadas por pixeis. Existem três (sub-)tipos de imagens: imagens de ficheiro, imagens vazias, imagens de listas de dados (ver figura \ref{fig:cimage}). As primeiras são imagens pré-existentes em disco num dos formatos permitidos, as segundas são imagens por nós criadas, pixel a pixel, e as terceiras são imagens dadas no formato lista de listas de pixeis, semelhante ao acima referido para matrizes. Nestes dois últimos casos o formato em que as imagens são guardadas externamente depende do sufixo usado no nome, sendo que na ausência de sufixo o formato por defeito é o jpeg.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{visoes_2/imagens/cimage.eps}
\caption{Os tipos de cImage}
\label{fig:cimage}
\end{center}
\end{figure}

\subsubsection{Janelas} O construtor do tipo janela chama-se \texttt{ImageWin()}. Tem por argumentos o nome da janela, a sua largura e a sua altura. Existem vários outros métodos como sejam o que permite obter a largura da janela (\texttt{getWidth()}),  a altura da janela (\texttt{getHeight()}), as coordenadas do rato (\texttt{getMouse()}), ou definir a cor de fundo (\texttt{setBackground()}).

\subsubsection{Imagens} Para cada tipo de imagem existe um construtor. Assim temos três construtores específicos: \texttt{FileImage()},  \texttt{EmptyImage()} e  \texttt{ListImage()}.  As imagens podem ser desenhadas numa janela (\texttt{draw()}), salvas (\texttt{save()}), podemos obter a sua largura (\texttt{getWidth()}) e/ou a sua altura (\texttt{getHeight()}), modificar um determinado pixel (\texttt{setPixel()}), entre outras operações.

\subsubsection{Pixeis} O construtor designa-se por \texttt{Pixel()}. Podemos consultar cada um dos três canais (\texttt{getRed()},\texttt{getGreen()},\texttt{getBlue()}), ou modificar cada uma das componentes (\texttt{setRed()},\texttt{setGreen()},\texttt{setBlue()}).

\section{Exemplos Básicos}

O\marginlabel{Janelas} primeiro exemplo envolve simplesmente a criação de uma janela. Apenas temos que indicar o seu nome e a sua resolução (largura e altura em pixeis).

\begin{lstlisting}
import cImage

def cria_janela(nome,largura,altura):
    janela= cImage.ImageWin(nome,largura,altura)
    janela.exitOnClick()
    
 if __name__ =='__main__':
    cria_janela('Janela Indiscreta', 320,240)
\end{lstlisting}

A execução do código produz a imagem da figura \ref{fig:jan_1}.O método \texttt{exitOnclick()} actua sobre objectos do tipo \texttt{ImageWin()} e permite encerrar a janela e abandonar a execução. Tipicamente é a ultima acção a realizar pelos programas.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{visoes_2/imagens/janela_1.png}
\caption{Um janela simples}
\label{fig:jan_1}
\end{center}
\end{figure}

Como se verifica a janela tem um fundo branco. Mas podemos criar uma janela em que a cor de fundo é, por exemplo, vermelha. Vejamos agora alguns aspectos básicos envolvendo janelas e o desenho de formas simples. O primeiro exemplo mostra a criação de uma janela em que a cor de fundo é vermelha\footnote{A cor também pode ser definida em hexadecimal ou através de um tuplo (r,g,b). Por exemplo, a cor vermelha podia ter sido definida pela cadeia de caracteres '\#ff0000' ou por (255,0,0).}.

\begin{lstlisting}
def cria_janela_cor(nome,largura,altura,cor):
    janela= cImage.ImageWin(nome,largura,altura)
    janela.setBackground(cor)
    janela.exitOnClick()
    
if __name__ =='__main__':
    cria_janela_cor('Teste de Cor de Fundo', 320,240,'red')
\end{lstlisting}

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.5]{visoes_2/imagens/red.png}
\caption{Fundo vermelho}
\label{fig:red}
\end{center}
\end{figure}


As\marginlabel{Imagens} janelas existem, como referimos, como contentores para objectos que são imagens. Estas imagens ou são criadas por nós ou existem guardadas externamente em disco. O caso mais simples é o de uma imagem por nós criada \ldots sem nada.

\begin{lstlisting}
import cImage

def cria_imagem_vazia(largura,altura):
    imagem = cImage.EmptyImage(largura,altura)
    return imagem

def mostra_imagem_simples(imagem):
    # Dimensão
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    # Cria janela
    janela = cImage.ImageWin('Imagem', 2*largura,2*altura)
    # Mostra imagem na janela
    imagem.draw(janela)
    # Termina
    janela.exitOnClick()    
\end{lstlisting}


\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{visoes_2/imagens/janela_2.png}
\caption{Uma imagem em branco  \ldots é preta!}
\label{fig:jan_2}
\end{center}
\end{figure}


Alguns aspectos a referir. Em primeiro lugar,  criámos uma janela que tem o dobro do tamanho em cada dimensão do que o da imagem criada (linha 12) e o posicionamento da imagem é feito por defeito a partir do canto superior esquerdo, que corresponde às coordenadas $(0,0)$. Em segundo lugar, a imagem criada é preta. Estes dois aspectos podem ser alterados, ou seja podemos posicionar a imagem   noutro local da janela e podemos alterar a cor da imagem. Sem mexer no código de modo substantivo podemos alterar a sua cor (linha 5)  e posicionar a imagem (linha 6) e como se pode ver na figura  \ref{fig:jan_3}.

\begin{lstlisting}
if __name__ =='__main__':
    largura = 320
    altura = 240
    imagem = cImage.EmptyImage(largura,altura)
    imagem.setSolidColor((0,0,255))
    imagem.setPosition(largura//2,altura//2)
    mostra_imagem_simples(imagem)
\end{lstlisting}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{visoes_2/imagens/janela_3.png}
\caption{Lidar com a cor e a posição}
\label{fig:jan_3}
\end{center}
\end{figure}


\begin{bclogo}[couleur=black!20,arrondi=0.2,barre=snake,tailleOndu=1.5,logo=\bcbook]{Coordenadas}
Cada pixel tem associado as suas coordenadas. As coordenadas $(x,y) = (0,0)$ situam-se no canto superior esquerdo da imagem. Os valores de $x$ crescem horizontalmente para a direita, enquanto os valores de $y$ crescem verticalmente para baixo. A figura ilustra a situação.

%\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.68]{visoes_2/imagens/coordenadas.eps}
%\caption{Sistema de coordenadas}
\label{fig:coord}
\end{center}
%\end{figure}
\end{bclogo}


Falta\marginlabel{Pixeis} apenas referir como podemos alterar os pixeis individualmente. O caso que apresentamos refere-se a uma situação simples em que traçamos uma linha horizontal vermelha, sobre fundo preto.

\begin{lstlisting}
 def desenha_linha(imagem):
    altura = imagem.getHeight()
    largura = imagem.getWidth()
    janela = cImage.ImageWin('Imagem',largura,altura)
    pix = cImage.Pixel(255,0,0)
    for col in range(largura):
        imagem.setPixel(col, altura//2,pix)
    imagem.draw(janela)
    janela.exitOnClick()
\end{lstlisting}


Dados estes exemplos sabemos agora que as questões centrais a resolver no tratamento de imagens são essencialmente três: definir uma janela, definir uma imagem (construindo-a, ou carregando-a do disco seguido de eventual manipulação), e mostrar a imagem.  Apresentamos de seguida um exemplo simples, sem manipulação dos pixeis, que envolve estes três aspectos. 
\begin{lstlisting}
import cImage

def mostra_imagem(img_fich):
    # Carrega a imagem do disco
    imagem = cImage.FileImage(img_fich)
    # Obtem Componentes
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    # Cria janela
    janela = cImage.ImageWin('Imagem', largura,altura)
    # Mostra imagem na janela
    imagem.draw(janela)
    # Termina
    janela.exitOnClick()
    
if __name__ =='__main__':
    mostra_imagem('/images/calvin_leia.jpg')   
\end{lstlisting}

Este exemplo pretende ser um modelo para o programa principal dos exemplos que apresentamos de seguida. O código, com os seus comentários, é auto-explicativo. Ao executar obtemos a imagem da figura \ref{fig:cl}.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{visoes_2/imagens/calvin_leia.png}
\caption{Reproduzir uma imagem}
\label{fig:cl}
\end{center}
\end{figure}


\section{Manipulações simples}

\subsubsection{Negativo} O primeiro exemplo simples em que uma imagem é manipulada consistirá na obtenção do  seu negativo. Sabemos, por exemplo, que o preto se transforma em branco, o verde em magenta,  o vermelho em ciano, o azul em amarelo. A forma de  conseguir esta transformação consiste em substituir o valor da intensidade em cada canal pela sua diferença para o valor máximo 255. Deste modo a nossa solução é trivial: depois de carregar a imagem, vamos percorrê-la pixel a pixel transformando cada um no seu equivalente negativo.

\begin{lstlisting}
import cImage

# Negativo de imagem
def main_negativo(imagem_ficheiro):
    """Constrói e vizualiza o negativo de uma imagem."""
    # Obtém imagem
    imagem = cImage.FileImage(imagem_ficheiro)
    # Fabrica o negativo
    imagem_nova = negativo_imagem(imagem)
    # Define janela
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    janela = cImage.ImageWin('Negativo',2*largura, altura)
    # vizualiza
    imagem.draw(janela)
    imagem_nova.setPosition(largura+1,0)
    imagem_nova.draw(janela)
    # Termina
    janela.exitOnClick()
  
def negativo_imagem(imagem):
    """ Negativo de uma imagem."""
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    imagem_nova = cImage.EmptyImage(largura,altura)
    # percorre pixel a pixel
    for coluna in range(largura):
        for  linha in range(altura):
            # transforma
            pixel_original = imagem.getPixel(coluna,linha)
            novo_pixel = negativo_pixel(pixel_original)
            imagem_nova.setPixel(coluna,linha,novo_pixel)
    return imagem_nova
\end{lstlisting}

\begin{comment}
\begin{lstlisting}
import cImage

def negativo_pixel(pixel):
    red = 255 - pixel.getRed()
    green = 255 - pixel.getGreen()
    blue = 255 - pixel.getBlue()
    novo_pixel = cImage.Pixel(red,green,blue)
    return novo_pixel

def negativo_imagem(imagem_ficheiro):
    """ Constrói o negativo de uma imagem gfuardada em disco."""
    imagem_velha = cImage.FileImage(imagem_ficheiro)
    largura = imagem_velha.getWidth()
    altura = imagem_velha.getHeight()
    janela = cImage.ImageWin('Negativos',2*largura,altura)
    imagem_velha.draw(janela)
    imagem_nova = cImage.EmptyImage(largura,altura)
    for coluna in range(largura):
        for  linha in range(altura):
            pixel_original = imagem_velha.getPixel(coluna,linha)
            novo_pixel = negativo_pixel(pixel_original)
            imagem_nova.setPixel(coluna,linha,novo_pixel)
    imagem_nova.setPosition(largura+1,0)
    imagem_nova.draw(janela)
    janela.exitOnClick()
\end{lstlisting}
\end{comment}

Vale a pena perder algum tempo com este código pois ele ilustra um padrão para percorrer uma imagem semelhante ao apresentado para o percurso de matrizes\footnote{Devemos ter em atenção no entanto que quando acedemos a uma matriz, na forma de listas de listas, primeiro indicamos a linha e depois a coluna. No caso das imagens, indicamos primeiro a posição ao longo do eixo dos x (largura) e depois ao longo do eixo dos y (altura).}. Começamos por definir o nosso programa principal (\texttt{main\_negativo}) que decompõe numa sequência de cinco passos a concretização da solução para o nosso problema: obtenção da imagem, fabrico do negativo, definição da janela onde vão ser colocadas as duas imagens, a visualização das imagens e o abandono  do programa. O negativo é fabricado sem destruição do original, sendo criada uma imagem vazia que depois vai receber os pixeis modificados. O uso do método \texttt{setPosition()} permite-nos colocar as duas imagens neste caso o ao lado uma da outra (ver  figura \ref{fig:negat}). Como se pode ver pelo código da função \texttt{negativo\_imagem}, abstraímos numa definição (i.e., \texttt{negativo\_pixel} a transformação de um pixel no seu negativo. Isto permite melhor legibilidade e pôr em evidência um padrão geral de tratamento de \textbf{todos} os pixeis de uma imagem pela mesma função de transformação: dois ciclos imbricados que vão gerando de modo ordenado as coordenadas  dos pixeis. 

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{visoes_2/imagens/negativo.png}
\caption{Negativo de uma imagem}
\label{fig:negat}
\end{center}
\end{figure}

\subsubsection{Cinzentos} Esta ideia de abstracção pode ser ilustrada se agora pretendermos transformar a imagem de colorida para escala de cinzentos. Basta substituir no programa principal a função de transformação por uma que forma o valor na escala de cinzentos. A forma mais simples de o fazer é usar como valor de todos os canais a média dos valores na imagem original:

\[ cinza = \frac{red + green + blue}{3} \]

\begin{lstlisting}
import cImage

def main_cinzento(imagem_ficheiro):
    """Constrói e vizualiza a escala de cinzentos de uma imagem."""
    # Obtém imagem
    imagem = cImage.FileImage(imagem_ficheiro)
    # Fabrica a escala de cinzentos
    imagem_nova = cinzento_imagem(imagem)
    # Define janela
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    janela = cImage.ImageWin('Cinzento',2*largura, altura)
    # vizualiza
    imagem.draw(janela)
    imagem_nova.setPosition(largura+1,0)
    imagem_nova.draw(janela)
    # Termina
    janela.exitOnClick()
  
def cinzento_imagem(imagem):
    """ Escala de cinzentos de uma imagem."""
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    imagem_nova = cImage.EmptyImage(largura,altura)
    # percorre pixel a pixel
    for coluna in range(largura):
        for  linha in range(altura):
            # transforma
            pixel_original = imagem.getPixel(coluna,linha)
            novo_pixel = cinzento_pixel(pixel_original)
            imagem_nova.setPixel(coluna,linha,novo_pixel)
    return imagem_nova

def cinzento_pixel(pixel):
    """ Converte um pixel para escala de cinzentos."""
    vermelho = pixel.getRed()
    verde = pixel.getGreen()
    azul = pixel.getBlue()
    int_media = (vermelho + verde + azul) // 3
    novo_pixel = cImage.Pixel(int_media,int_media, int_media)
    return novo_pixel
\end{lstlisting}

\begin{comment}
\begin{lstlisting}
import cImage

def pixel_cinzento(pixel):
    """ Converte um pixel para escala de cinzentos."""
    vermelho = pixel.getRed()
    verde = pixel.getGreen()
    azul = pixel.getBlue()   
    int_media = (vermelho + verde + azul) // 3
    novo_pixel = cImage.Pixel(int_media,int_media, int_media)
    return novo_pixel

def imagem_cinzentos(imagem_fich):
    """ Transforma para escala de cinzentos a imagem."""

    imagem = cImage.FileImage(imagem_fich)
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    
    janela = cImage.ImageWin('Escala de cinzentos', 2* largura, altura)
    imagem.draw(janela)
    nova_imagem=cImage.EmptyImage(largura,altura)
    
    for coluna in range(largura):
        for linha in range(altura):
            pixel = imagem.getPixel(coluna,linha)
            novo_pixel = pixel_cinzento(pixel)
            nova_imagem.setPixel(coluna,linha,novo_pixel)
    nova_imagem.setPosition(largura+1,0)
    nova_imagem.draw(janela)
    janela.exitOnClick()
    \end{lstlisting}
    \end{comment}

 Executando o código para a imagem \ref{fig:cl} obtemos o resultado da figura \ref{fig:cinza}.
 
 \begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{visoes_2/imagens/cinza.png}
\caption{Escala de cinzentos}
\label{fig:cinza}
\end{center}
\end{figure}
 
 Esta solução simplifica um pouco o problema da escala de cinzentos, pois a visão humana tem uma percepção da luminância diferente e dependente do canal considerado (vermelho, verde e azul). O código  que se segue calcula a média pesada dos três canais.
 
 \begin{lstlisting}
def cinzento_pixel(pixel):
    """ Converte um pixel para escala de cinzentos tendo em atenção a diferença dos canais."""
    vermelho = pixel.getRed()
    verde = pixel.getGreen()
    azul = pixel.getBlue()
    
    int_media = int(0.299*vermelho + 0.587*verde + 0.114*azul) // 3
    novo_pixel = cImage.Pixel(int_media,int_media, int_media)
    return novo_pixel
\end{lstlisting}

Usando esta versão obtemos uma imagem em escala de cinzento como se pode ver na figura \ref{fig:cinzab}.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{visoes_2/imagens/cinzab.png}
\caption{Mais cinzento}
\label{fig:cinzab}
\end{center}
\end{figure}

Mais uma vez, o código apresentado põe em relevo um padrão de transformação de toda uma imagem pixel a pixel: percorremos as colunas e, para uma dada coluna todas as linhas; identificado o pixel transformamo-lo.

\subsubsection{Sepia} Todos conhecem aquele tom amarelado típico das fotografias antigas. Esse efeito pode ser obtido mediante o recurso a fórmulas de transformação do valor de cada canal:

\begin{align*}
r_n = r \times 0.393 + g \times 0.769 + b \times 0.189)\\
g_n = r \times 0.349 + g \times 0.686 + b \times 0.168)\\
b_n = r \times 0.272 + g \times 0.534 + b \times 0.131)
\end{align*}

Daqui resulta o programa seguinte (onde se tem que ter o cuidado de manter os novos valores dentro do intervalo (0,255).).

\begin{lstlisting}
def sepia_pixel(pixel):
    """ Tempo do passado."""
    r = pixel.getRed()
    g = pixel.getGreen()
    b = pixel.getBlue()
    novo_r = int((r * 0.393 + g * 0.769 + b * 0.189))
    novo_g = int((r * 0.349 + g * 0.686 + b * 0.168))
    novo_b = int((r * 0.272 + g * 0.534 + b * 0.131))
    if novo_r > 255: novo_r = r 
    if novo_g > 255: novo_g = g 
    if novo_b > 255: novo_b = b
    novo_pixel = cImage.Pixel(novo_r,novo_g,novo_b)
    return novo_pixel  
\end{lstlisting}

Para obter a transformação de uma imagem para sepia só precisamos de usar o modelo já conhecido. O resultado é mostrado na figura \ref{fig:sepia}.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{visoes_2/imagens/sepia.png}
\caption{Sepia}
\label{fig:sepia}
\end{center}
\end{figure}


\section{Intermezzo: abstracção}

Os exemplos anteriores envolvem a alteração de cada pixel de uma imagem de acordo com um determinado efeito pretendido: passar a negativo, passar a escala de cinzentos, passar a sepia. Para resolver esta questão implementámos a função de transformação do pixel e criámos uma função geral para cada caso. Mas podemos aplicar o \textbf{princípio da abstracção} baseados na ideia de que só a função é que muda. O objectivo é ter uma  única definição para \textbf{todos} os casos. Isto consegue-se passando a função como argumento do programa geral. Lembre-se que as definições também são objectos! Daí o novo código que se segue.

\begin{lstlisting}
def transforma_imagem(imagem, funcao):
    """ Manipula uma imagem de acordo com uma função."""
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    nova_imagem = cImage.EmptyImage(largura,altura)
    for coluna in range(largura):
        for linha in range(altura):
            pixel = imagem.getPixel(coluna,linha)
            novo_pixel = funcao(pixel)
            nova_imagem.setPixel(coluna,linha, novo_pixel)
    return nova_imagem
\end{lstlisting}

O programa específico de transformação é usado por um programa principal que se encarrega de mostrar as imagens numa janela.

\begin{lstlisting}
def main_funcao(imagem_ficheiro, funcao):
    """Transforma uma imagem de acordo com a funcao."""
    # Obtém imagem
    imagem = cImage.FileImage(imagem_ficheiro)
    # Transforma a imagem
    imagem_nova = transforma_imagem(imagem, funcao)
    # Define janela
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    janela = cImage.ImageWin( funcao.__name__,2*largura, altura)
    # vizualiza
    imagem.draw(janela)
    imagem_nova.setPosition(largura+1,0)
    imagem_nova.draw(janela)
    # Termina
    janela.exitOnClick()
\end{lstlisting}

Notar o modo como definimos o título da janela usando o atributo \texttt{\_\_name\_\_} do objecto \texttt{funcao}.

\subsubsection{Brilho} Nem sempre podemos usar este padrão em toda a sua pureza. Escurecer, ou tornar mais clara, um imagem resume-se a diminuir, ou a aumentar, respectivamente, de um certo valor a intensidade de cada canal. Como se trata  de uma operação que envolve toda a imagem, basta então definir a função de transformação de um pixel e usar o mesmo modelo geral dos casos anteriores.

\begin{lstlisting}
def brilho_pixel(pixel,brilho):
    """ Altera o brilho do pixel."""
    r = restringe(pixel.getRed() + brilho, 0, 255)
    g = restringe(pixel.getGreen() + brilho, 0, 255)
    b = restringe(pixel.getBlue() + brilho,0, 255)
    novo_pixel = cImage.Pixel(r,g,b)
    return novo_pixel

def restringe(canal,inf,sup):
    if canal > sup:
        canal = sup
    elif canal < inf:
        canal = inf
    return canal
\end{lstlisting}


Para escurecer o valor do brilho deve ser negativo e para aumentar deve ser positivo. As imagens que se seguem (ver figura \ref{fig:brilho})  resultam de uma variação de 100. Notar que os valores têm que ser eventualmente  truncados, recorrendo à função genérica \texttt{restringe},  para não saírem do intervalo permitido, no caso de imagens (0,255).

\begin{figure}[h] \centering
\subfloat[Mais Claro]
{\includegraphics [scale=0.3]{visoes_2/imagens/brilho_mais.png}\label{fig:bmais}}
\qquad
\subfloat[Mais Escuro]
{\includegraphics [scale=0.3]{visoes_2/imagens/brilho_menos.png}\label{fig:bmenos}}

\caption{Alterando o brilho}\label{fig:brilho}
\end{figure}



\section{Exemplos complementares}
Apresentados os princípios básicos e alguns exemplos de programas que modificam de modo uniforme uma imagem, dando origem a um padrão de programa, está na altura de passar a exemplos diferentes.


\subsubsection{Colorir o chão} Suponha que pretende cobrir o chão da sua cozinha com quadrados coloridos. As cores devem ser colocadas de acordo com um padrão. A figura \ref{fig:chao} mostra um exemplo possível. As duas cores são parte da especificação, ou seja devem ser consideradas como parâmetros do programa.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.8]{visoes_2/imagens/mosaico2.jpg}
\caption{O chão da cozinha}
\label{fig:chao}
\end{center}
\end{figure}

 Olhando para a figura acima vemos que existe um \textbf{padrão}: os quadrados são colocados de modo alternado. Por outro lado, como é dito  as formas são quadradas. Finalmente, embora na imagem a cozinha tenha uma dimensão 4 x 3, nós queremos uma solução \textbf{geral}, ou seja, para cozinhas de dimensão $n \times m$. Do ponto de vista informático o que precisamos fazer? De acordo com o princípio geral deste tipo de aplicações vamos ter que responder a três sub-problemas:
\begin{itemize}
\item Definir uma janela onde possam ser colocados os azulejos;
\item Gerar os quadrados de duas cores
\item Posicionar os quadrados  na janela e mostrar a imagem
\end{itemize}




A primeira questão, obriga-nos a saber a dimensão dos quadrados e as dimensões $n \times m$ da cozinha. Claro que as duas cores também são importantes. Mas disso trataremos de seguida. Daí o nosso programa principal poder ser definido do seguinte modo:

\begin{lstlisting}
def main1(nx,ny,lado,cores):
    janela = cImage.ImageWin('Ladrilhos',nx * lado, ny*lado)
   # -- resto do programa  a definir aqui 
    janela.exitOnclick()
\end{lstlisting}



A segunda questão, remete para a geração de quadrados coloridos. Trata-se de uma questão geral, pelo que a solução para o problema de gerar quadrados de \textbf{duas ou mais} cores diferentes pode ser resolvido por um único programa que gera um quadrado de uma cor específica\footnote{Aplicamos aqui de novo o princípio da abstracção procedimental.}. Esse programa pode depois ser chamado tantas vezes quantas as necessárias sendo a cor um parâmetro do programa.
\begin{lstlisting}
def quadrado(lado,cor):
    """  Cria um quadrado colorido de lado. """
    imagem = cImage.EmptyImage(lado,lado)
    pixel = cImage.Pixel(cor[0],cor[1],cor[2])
    for linha in range(lado):  
        for coluna in range(lado):
            imagem.setPixel(coluna,linha,pixel)       
    return imagem
\end{lstlisting}

Como se pode ver, começamos por criar uma imagem vazia, com as dimensões apropriadas. Depois definimos um pixel com a cor indicada. A   cor é dada por um tuplo com os valores (r,g,b). Finalmente, colocamos o pixel em cada ponto da imagem.

Falta agora a parte mais difícil, a questão três: posicionar os quadrados e mostrar a imagem. Pensemos um pouco e olhemos para a figura \ref{fig:lad}, que \textbf{ilustra} o caso de quadrados 2 x 2, para serem colocados numa cozinha 4 x 3.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.85]{visoes_2/imagens/ladrilhos.jpg}
\caption{O problema do posicionamento}
\label{fig:lad}
\end{center}
\end{figure}


Os círculos alaranjados indicam os pontos onde cada quadrado deve começar a ser desenhado. Correspondem aos índices de uma matriz 4 x 3. (0,0), (1,0), (2,0) ....É aí que devemos colocar as imagens. Mas, é claro, que neste caso estes pontos estão afastados entre si do valor do lado. Assim, na realidade, em termos da imagem, esses pontos são (0,0), (lado,0), (2*lado, 0), ..... Assim o problema reduz-se a colocar 4 x 3 = 12 imagens nas posições referidas. Isso faz-se com dois ciclos \textbf{for}, um dentro do outro, em que são gerados os \textbf{índices} da matriz, calculando-se em função deles o posicionamento na \textbf{imagem}. Para simplificar admitamos, por agora, que os quadrados são \textbf{todos} da mesma cor:

\begin{lstlisting}
def cozinha_mono(nx,ny,lado, cor, janela):
    """ Desenha os azulejos todos da mesma cor."""
    for coluna in range(nx):
        for linha in range(ny):
            imagem = quadrado(lado, cor)
            imagem.setPosition(coluna * lado,linha * lado)
            imagem.draw(janela)
\end{lstlisting}


Se executarmos o programa apenas vemos desenhar uma cozinha com o chão todo da mesma cor. Não é muito impressionante! Então com alternar entre duas cores?? Um modo possível é notar que a soma das posições (x,y) do canto superior esquerdo das imagens são, alternadamente, pares e ímpares. E sabermos como determinar se um número é par. Logo:
\begin{lstlisting}
def cozinha_poli(nx,ny,lado, cores, janela):
    """ Desenha os azulejos com duas cores alternadas."""
    for coluna in range(nx):
        for linha in range(ny):
            if (coluna + linha)%2 == 0:
                # par
                imagem = quadrado(lado, cores[0])
            else:
                # ímpar
                imagem = quadrado(lado, cores[1])
                
            imagem.setPosition(coluna * lado,linha * lado)
            imagem.draw(janela)
\end{lstlisting}


Juntando agora todas as peças temos o programa completo:

\begin{lstlisting}
import cImage

def cozinha_poli(nx,ny,lado, cores, janela):
    """ Desenha os azulejos com duas cores alternadas."""
    for coluna in range(nx):
        for linha in range(ny):
            if (coluna + linha)%2 == 0:
                # par
                imagem = quadrado(lado, cores[0])
            else:
                # ímpar
                imagem = quadrado(lado, cores[1])
                
            imagem.setPosition(coluna * lado,linha * lado)
            imagem.draw(janela)
                
def quadrado(lado,cor):
    """
    Cria um quadrado colorido de lado.
    """
    imagem = cImage.EmptyImage(lado,lado)
    pixel = cImage.Pixel(cor[0],cor[1],cor[2])
    for linha in range(lado):  
        for coluna in range(lado):
            imagem.setPixel(coluna,linha,pixel)       
    return imagem

def main1(nx,ny,lado,cores):
    janela = cImage.ImageWin('Ladrilhos',nx * lado, ny*lado)
    cozinha_poli(nx,ny,lado,cores, janela) 
    janela.exitOnClick()
    
if __name__=='__main__':
    main1(4,3,50,[(255,0,0),(0,0,255)])

\end{lstlisting}

\subsubsection{Distorcer uma imagem}

Pretendemos implementar uma função que nos permita ampliar uma imagem eventualmente com distorção. A figura \ref{fig:dist} ilustra o que se pretende. No exemplo apresentado a imagem foi ampliada duas vezes em largura e três vezes em altura.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{visoes_2/imagens/distorcer.png}
\caption{Distorcer uma imagem}
\label{fig:dist}
\end{center}
\end{figure}

Como podemos resolver esta questão? Uma ideia muito simples consiste em \textit{ampliar cada pixel} de acordo com dois factores: um para a largura ($factor_x$) e outro para a altura ($factor_y$). Ou seja, Um pixel vai ser clonado um número de vezes igual a $factor_x \times factor_y$. A figura \ref{fig:clonar} exemplifica a ideia para o caso de $3 \times 2$.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{visoes_2/imagens/distorcer.eps}
\caption{Clonar um pixel}
\label{fig:clonar}
\end{center}
\end{figure}


Entendida a ideia fica a questão de saber  como determinar as posições dos pixeis na imagem final. Após alguma reflexão não é difícil chegar à seguinte solução semelhante à encontrada para o problema dos ladrilhos (ver uma vez mais a figura \ref{fig:clonar}):

\begin{lstlisting}
            pixel = imagem.getPixel(coluna, linha)
            # repete o pixel numa área definida pelos factores
            for i_x in range(factor_x):
                for i_y in range(factor_y):
                    nova_imagem.setPixel(factor_x * coluna + i_x, factor_y * linha + i_y, pixel)
\end{lstlisting}

Neste modo, um pixel vai ser clonado numa área rectangular definida pelos dois factores de distorção. Este processo deve ser repetido para todos os pixeis da imagem original. Os exemplos anteriores mostram como se pode percorrer uma imagem pixel a pixel. Daí o código:


\begin{lstlisting}
def distorcer(imagem,factor_x, factor_y):
    """
    Altera a imagem de acordo com os factores.
    Estes devem ser números inteiros positivos.
    """
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    nova_imagem = cImage.EmptyImage(factor_x * largura, factor_y * altura)
    for coluna in range(largura):
        for linha in range(altura):
            pixel = imagem.getPixel(coluna, linha)
            # repete o pixel numa área definida pelos factores
            for i_x in range(factor_x):
                for i_y in range(factor_y):
                    nova_imagem.setPixel(factor_x * coluna + i_x, factor_y * linha + i_y, pixel)
    return nova_imagem
\end{lstlisting}

O que falta fazer resume-se: (1) a criar uma janela onde se possam guardar as imagens e, (2) mostrar o resultado.

\begin{lstlisting}
def ampliar(imagem, factor_x, factor_y):
    """
    Distorce uma imagem de acordo com os factores indicados.
    Cada pixel vai darorigem a um rectângulo de dimensões
    factor_x X factor_y.
    """  
    # Cria imagens
    img = cImage.FileImage(imagem)
    nova_img = distorcer(img, factor_x,factor_y)
    # Cria janela
    largura = img.getWidth()
    altura = img.getHeight()    
    janela = cImage.ImageWin('Distorce', (factor_x + 1)  * largura  , factor_y  * altura )
    # Coloca imagens
    img.draw(janela)
    nova_img.setPosition(largura + 1,0)
    nova_img.draw(janela)
    # Termina
    janela.exitOnClick()    
\end{lstlisting}

Note-se como se determina o tamanho da janela e a forma como se procede ao posicionamento das imagens.

\subsubsection{Espelho}
Vamos agora resolver o problema de pegar numa metade de uma imagem efectuar uma cópia e juntar as duas partes como se uma fosse a imagem no espelho da outra. Vamos supor que usamos a metade  esquerda da nossa imagem original. A figura \ref{fig:espelho} mostra o efeito pretendido.


\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{visoes_2/imagens/espelho.png}
\caption{Espelho vertical}
\label{fig:espelho}
\end{center}
\end{figure}

A questão que se coloca é a de saber  onde vai ficar a cópia de um dado pixel da metade esquerda. Uma observação evidente é de que, dado o facto de o espelho ser feito em função de um eixo vertical, a linha do pixel e da cópia é a mesma. Já em relação à coluna note-se que estes dois pixeis devem estar a igual distância da extremidades (ou do meio)  da imagem final. A figura \ref{fig:pp} tenta mostrar a situação.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.8]{visoes_2/imagens/espelho.eps}
\caption{Onde colocar os pixeis?}
\label{fig:pp}
\end{center}
\end{figure}

Com a informação e os exemplos que já acumulámos vamos chegar sem dificuldades a uma solução informática.

\begin{lstlisting}
def espelho_v_e(imagem):
    """Faz o espelho vertical de uma imagem, usando a sua parte esquerda."""
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    nova_imagem = cImage.EmptyImage(largura,altura)
    for coluna in range(largura//2):
        for linha in range(altura):
            pixel = imagem.getPixel(coluna, linha)
            nova_imagem.setPixel(coluna,linha,pixel)
            nova_imagem.setPixel(largura - coluna - 1,linha,pixel)
    return nova_imagem 
    

def espelhar(imagem_fich):
    imagem = cImage.FileImage(imagem_fich)
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    janela = cImage.ImageWin('Espelho Vertical - Esquerda', 2*largura,altura)
    nova_imagem = espelho_v_e(imagem)
    nova_imagem.setPosition(largura + 1, 0)
    imagem.draw(janela)
    nova_imagem.draw(janela)
    janela.exitOnClick()   
\end{lstlisting}


A primeira função cria a janela, cria a nova imagem e coloca tudo na janela. A segunda função (\texttt{espelhar}) faz o trabalho de manipulação da imagem de acordo com a estratégia delineada.


\section{Filtros}

Acontece com frequência vermos imagens que sofrem de um problema conhecido como pixelização: de um modo simples esse efeito caracteriza-se por conseguirmos ver os pixeis. Muitas vezes tal resulta, por exemplo, de termos deliberadamente manipulado a imagem para esconder certa informação ou de termos ampliado a imagem. A baixa resolução origina o efeito de  pixelização. Uma maneira de melhorar a qualidade da imagem baseia-se numa técnica que permite suavizar as transições entre intensidades de pixeis vizinhos.  A figura \ref{fig:blur} mostra uma imagem pixelizada e o resultado da suavização das transições.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{visoes_2/imagens/blur.png}
\caption{Tratamento da pixelização}
\label{fig:blur}
\end{center}
\end{figure}

É notório o desaparecimento do efeito de escada nas linhas inclinadas. Vamos ver como podemos implementar o respectivo programa de suavização da imagem. Para tal iremos modificar o valor da intensidade de um pixel em função das intensidades dos seus 9 vizinhos (ver figura \ref{fig:viz}).

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.8]{visoes_2/imagens/vizinhos.eps}
\caption{Vizinhança}
\label{fig:viz}
\end{center}
\end{figure}

A função  que vamos considerar substitui a intensidade de cada canal pelo valor \textbf{médio} das intensidades dele e dos seus vizinhos. Comecemos por resolver essa questão.

\begin{lstlisting}
def media(coluna, linha, imagem):
    """Calcula o valor médio dos pixeis na vizinhança do pixel (coluna,linha)."""
    # Extrai pixeis
    vizinhos = []
    for c in [-1,0,1]:
        for l in [-1,0,1]:
            vizinhos.append(imagem.getPixel(coluna+c,linha+l))                    
    # Calcula pixel "médio" por canal
    r = sum([vizinhos[i].getRed() for i in range(9)])//9
    g = sum([vizinhos[i].getGreen() for i in range(9)])//9
    b = sum([vizinhos[i].getBlue() for i in range(9)])//9
    # Constrói Pixel
    novo_pixel = cImage.Pixel(r,g,b)
    return novo_pixel
\end{lstlisting}

A nossa solução desdobra-se em três passos: (1) extrair a lista dos 9 pixeis que formam a vizinhança (linhas 4 a 7); (2) calcular o valor médio por canal (linhas 9 a 11); e (3) construir o novo pixel (linha 13). A extracção dos pixeis vizinhos é feita fabricando o endereço de cada pixel através da sua posição \textbf{relativa} ao pixel que estamos a considerar. No segundo passo, vamos identificar todos os valores de cada canal específico (\textit{red},\textit{green} e \textit{blue}) e calcular a sua média. O uso de listas por compreensão ajuda-nos a resolver a questão e a tornar o programa mais legível. \\
A solução apresentada resulta de uma decomposição em sub-problemas que se traduz por primeiro determinar \textbf{todos} os vizinhos e só depois ir fazer a extracção da intensidade por canal. Esta é uma abordagem simples  e que nos permite  diminuir  a complexidade do problema inicial. E evidente que podemos proceder de outro modo juntando as duas fases: cada pixel é extraído e actualiza-se a soma.

\begin{lstlisting}
def media_2(coluna, linha, imagem):
    """Calcula o valor médio dos pixeis na vizinhança do pixel (coluna,linha)."""
    r,g,b = 0, 0, 0
    for c in [-1,0,1]:
        for l in [-1,0,1]:
            nova_coluna = coluna+c
            nova_linha = linha+l
            pixel = imagem.getPixel(nova_coluna, nova_linha)     
            # Actualiza pixel por canal
            r += pixel.getRed()
            g += pixel.getGreen()
            b += pixel.getBlue()
    
    novo_pixel = cImage.Pixel(r//9,g//9,b//9)
    return novo_pixel 
\end{lstlisting}

Deixamos ao leitor a reflexão acerca de qual das duas soluções é a melhor.\\

Sabemos agora como obter o valor médio de um pixel quando se considera a sua vizinhança. Falta agora percorrer a imagem, pixel a pixel, calcular o valor médio e construir a nova imagem. Mas isso já temos vindo a fazer ao longo do capítulo. Vejamos então o resultado.

\begin{lstlisting}
def suaviza(imagem):
    """Suaviza uma imagem."""
    # Inicializa
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    nova_imagem = cImage.EmptyImage(largura,altura) 
    # Percorre a imagem e calcula
    for coluna in range(1,largura-1):
        for linha in range(1,altura-1):
            novo_pixel = media(coluna,linha,imagem)
            nova_imagem.setPixel(coluna,linha,novo_pixel)
    return nova_imagem
\end{lstlisting}

Esta solução tem um aspecto menos simpático. Os pixeis da primeira e última linha e os da primeira e última coluna não têm os 9 vizinhos. Optámos então por não calcular os respectivos valores médios, razão pela qual os dois ciclos imbricados do programa evitam esses elementos. Deixamos ao leitor o cuidado de pensar uma solução em que esse problema desapareça (ver exercício \ref{ex:blur}).

\subsubsection{Convolução}
A operação que descrevemos para cada pixel pode ser apresentada  de outro modo. O novo valor de cada pixel é calculado como:

\[ pixel(x,y) = \frac{1}{9} \times \left( \sum_{c = -1}^1 \sum_{l=-1}^1 pixel(x+c,y+l)\right)\]


Esta expressão pode ser manipulada para se obter.

\[ pixel(x,y) =  \left( \sum_{c = -1}^1 \sum_{l=-1}^1 \frac{1}{9} \times pixel(x+c,y+l)\right)\]

Isto significa que a \textbf{soma do produto} de $\frac{1}{9}$  pelo valor de cada elemento da vizinhança. Podemos ainda visualizar esta operação de um modo simples, com se vê na figura \ref{fig:convolve}. Na figura, para simplificar,  apresentamos  apenas os valores hipotéticos para um dos canais.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{visoes_2/imagens/convolve.eps}
\caption{Aplicar um filtro a uma imagem}
\label{fig:convolve}
\end{center}
\end{figure}

Dizemos que aplicamos um \textbf{filtro} à imagem\footnote{Também designado por máscara ou núcleo.}\marginlabel{Filtro}.  O procedimento consiste percorrer  a imagem pixel a pixel,  alinhando o  \textbf{centro} do filtro com o pixel cujo novo valor queremos calcular e efectuando os cálculos com toda a vizinhança de acordo com a fórmula apresentada.  Podemos generalizar esta operação considerando a possibilidade de os elementos do filtro terem valores diferentes. A figura \ref{fig:gauss_1} mostra um exemplo da família dos filtros ditos \textbf{gaussianos}. Os valores aparecem na forma de fracções em que o denominador (no exemplo 16) é igual à soma de todos numeradores.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.8]{visoes_2/imagens/gauss_1.eps}
\caption{Filtro gaussiano}
\label{fig:gauss_1}
\end{center}
\end{figure}

Podemos adaptar a fórmula anterior  de modo trivial:


\[ pixel(x,y) =  \left( \sum_{c = -1}^1 \sum_{l=-1}^1 filtro(c,l) \times pixel(x+c,y+l)\right)\]


Em termos gerais designamos esta operação de \textbf{convolução}. A partir da última  fórmula facilmente se chega ao código que efectua a operação de convolução a um pixel.

\begin{lstlisting}
def convolucao(x,y, imagem, filtro):
    index = len(filtro) // 2
    r,g,b = 0, 0, 0
    for i in range(-index, index+1):
        for j in range(-index,index+1):
            pixel = imagem.getPixel(x+j,y+i)
            r += pixel.getRed() * filtro[j+index][i+index]
            g += pixel.getGreen() * filtro[j+index][i+index]
            b += pixel.getBlue() * filtro[j+index][i+index]
    r = restringe(int(r),0,255)
    g = restringe(int(g),0,255)
    b = restringe(int(b),0,255)
    novo_pixel = cImage.Pixel(r, g,b) 
    return novo_pixel
\end{lstlisting}

Note-se como se efectua a conversão das coordenadas do filtro relativas ao seu centro em coordenadas do filtro encarado como uma matriz, devido à sua representação como lista de listas. Atente-se ainda na necessidade de verificar se os valores obtidos se encontram na gama permitida, isto é, neste caso no intervalo $(0,255)$. Finalmente, verifique que o programa funciona desde que os filtros sejam matrizes quadradas $n\times n$, com $n$ um número ímpar.  Como se pode ver pela imagem da figura \ref{fig:gauss_2} este filtro melhora a qualidade da imagem contrariando o efeito da pixelização.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{visoes_2/imagens/gauss_1.png}
\caption{Aplicando um filtro gaussiano}
\label{fig:gauss_2}
\end{center}
\end{figure}

Para correr e programa necessitamos apenas de criar o programa envolvente que percorre a imagem pixel a pixel e desenha as imagens numa janela.

\begin{lstlisting}
import cImage

def convolucao(x,y, imagem, filtro):
    index = len(filtro) // 2
    r,g,b = 0, 0, 0
    for i in range(-index, index+1):
        for j in range(-index,index+1):
            pixel = imagem.getPixel(x+j,y+i)
            r += pixel.getRed() * filtro[j+index][i+index]
            g += pixel.getGreen() * filtro[j+index][i+index]
            b += pixel.getBlue() * filtro[j+index][i+index]
    r = restringe(int(r),0,255)
    g = restringe(int(g),0,255)
    b = restringe(int(b),0,255)
    novo_pixel = cImage.Pixel(r, g,b) 
    return novo_pixel


def mostra_convol(imagem, filtro):
    """ Convolução de uma  imagem."""  
    # Cria imagens
    img = cImage.FileImage(imagem)
    nova_img = transforma_convol(img,filtro)
    # Cria janela
    largura = img.getWidth()
    altura = img.getHeight()    
    janela = cImage.ImageWin('Convolução',2 * largura, altura )
    # Coloca imagens
    nova_img.setPosition(largura+1,0)
    img.draw(janela)
    nova_img.draw(janela)
    # Termina
    janela.exitOnClick() 
\end{lstlisting}

\subsubsection{Extrair características} 

Existem muitos filtros cada um com a sua finalidade\footnote{Ao leitor interessado sugerimos a consulta de um livro sobre processamento de imagens digitais. Nele encontrará seguramente toda a teoria que explica o uso dos filtros.}. Vamos agora expor de modo simples o uso conjugado da duas máscaras para a extracção de lados numa imagem.  As máscaras em questão são conhecidas por operadores de Sobel\marginlabel{Operadores de Sobel}. A figura \ref{fig:sobel} mostra as respectivas matrizes. A máscara da esquerda permite identificar linhas verticais e a da direita linhas horizontais. 

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.7]{visoes_2/imagens/sobel.eps}
\caption{Operadores de Sobel}
\label{fig:sobel}
\end{center}
\end{figure}

O algoritmo de detecção trabalha com uma imagem em escala de cinzentos. Funciona aplicando o filtro vertical, $val_x$, seguido do horizontal, $val_y$ a cada pixel. Depois calcula a intensidade recorrendo à fórmula $\sqrt{val_x^2 + val_y^2}$\footnote{A justificação deste método está fora do âmbito deste texto.}. Restringe o valor obtido ao intervalo $(0,255)$ e define o correspondente pixel. 


A implementação do algoritmo é a seguinte.

\begin{lstlisting}
import cImage
import math

def extrai_caract(imagem, mascara_1, mascara_2,limiar):
    """ Convolução de uma  imagem."""  
    # Cria imagens
    img_cor = cImage.FileImage(imagem)
    img = imagem_cinzentos(img_cor)
    nova_img = transforma_convol(img,mascara_1, mascara_2,limiar)
    # Cria janela
    largura = img.getWidth()
    altura = img.getHeight()    
    janela = cImage.ImageWin('Extrai Características',2 * largura, altura )
    # Coloca imagens
    nova_img.setPosition(largura+1,0)
    img.draw(janela)
    nova_img.draw(janela)
    # Termina
    janela.exitOnClick() 
    
def transforma_convol(imagem,mascara_1, mascara_2,limiar):
    """Imagem em escala de cinzentos."""
    largura = imagem.getWidth()
    altura = imagem.getHeight()
    nova_imagem = cImage.EmptyImage(largura, altura)
    index = len(mascara_1)//2   
    for coluna in range(index,largura-index):
        for linha in range(index,altura-index):
            val_x = convolve(coluna,linha,imagem, mascara_1)
            val_y = convolve(coluna,linha,imagem, mascara_2)
            val = restringe(math.sqrt(val_x**2 + val_y**2), 0, 255)
            novo_pixel = preto_branco_pixel(cImage.Pixel(val, val, val), limiar)
            nova_imagem.setPixel(coluna,linha,novo_pixel)
    return nova_imagem

def convolve(x,y, imagem, filtro):
    """Imagem em escala de cinzentos."""
    index = len(filtro) // 2
    r = 0
    for i in range(-index, index+1):
        for j in range(-index,index+1):
            pixel = imagem.getPixel(x+j,y+i)
            r += pixel.getRed() * filtro[j+index][i+index]
    r = restringe(int(r),0,255)
    return r
\end{lstlisting}

Executando o programa para diferentes valores do limiar obtemos resultados diversos (ver figura \ref{fig:op_sobel}). A qualidade das resultado também depende das características das imagens.

\begin{figure}[h] \centering
\subfloat[Limiar = 150]
{\includegraphics [scale=0.3]{visoes_2/imagens/extrai_150.png}\label{fig:c150}}
\qquad
\subfloat[Limiar = 100]
{\includegraphics [scale=0.3]{visoes_2/imagens/extrai_100.png}\label{fig:c100}}
\qquad
\subfloat[Limiar = 50]
{\includegraphics [scale=0.3]{visoes_2/imagens/extrai_50.png}\label{fig:c50}}
\caption{Operadores de Sobel}\label{fig:op_sobel}
\end{figure}


\section{O formato de imagem PPM}

Uma imagem pode ser armazenada em ficheiro de forma bastante simples, recorrendo ao formato PPM (Portable Pixel Map) que pode existir no modo RAW ou no modo ASCII. É sobre ficheiros neste último modo que nos iremos debruçar.  Um ficheiro PPM em modo ASCII come\c{c}a por uma linha com a palavra ``P3'', que identifica o formato PPM nesse modo. A segunda linha do mesmo ficheiro armazena um coment\'{a}rio, normalmente utilizado para identificar a aplica\c{c}\~{a}o respons\'{a}vel pela cria\c{c}\~{a}o do ficheiro. A terceira linha armazena dois valores inteiros, separados por um espa\c{c}o: o primeiro valor representa a largura da imagem e o segundo a sua altura. A quarta linha do ficheiro armazena um valor inteiro, que indica o valor m\'{a}ximo de cor presente na imagem. A partir da quinta linha, s\~{a}o armazenados os valores dos componentes RGB (Red, Green, Blue) de cada p\'{i}xel da imagem. Por exemplo, a quinta linha armazena o valor de {\bf vermelho} do primeiro p\'{i}xel, a sexta linha o valor de {\bf verde} do mesmo p\'{i}xel e a s\'{e}tima linha o seu valor de {\bf azul}. As 3 linhas seguintes no ficheiro armazenam os valores RGB do segundo p\'{i}xel da imagem, e assim sucessivamente. O exemplo seguinte ilustra as primeiras 10 linhas de um ficheiro PPM no formato ASCII. Trata-se neste exemplo de uma imagem criada pela aplica\c{c}\~{a}o GIMP e com dimens\~{a}o de 200x123 p\'{i}xeis:\\


\fbox{%
  \begin{minipage}{0.75\textwidth}
    \begin{alltt}
      	P3\\
	\# CREATOR: GIMP PNM Filter Version 1.1\\
	200 123\\
	255\\
	133\\
	120\\
	117\\
	123\\
	134\\
	212\\
	...
    \end{alltt}
  \end{minipage}
}\\


As imagens no formato PPM podem ser visualizadas recorrendo a v\'{a}rias aplica\c{c}\~{o}es, entre as quais o popular GIMP\footnote{Pode ser obtido em \url{http://www.gimp.org}.}.  O que nos interessa aqui é mostrar como podemos implementar um conversor entre imagens no formato que temos vindo a usar, em particular o formato \texttt{jpg}, e no formato \texttt{ppm}. 

\subsubsection{De ppm para jpg}

A tarefa de converter de \texttt{ppm} para o formato \texttt{jpg} será feito tendo por base o conhecimento que temos do formato destes ficheiros no modo ASCII. Na prática temos que implementar um pequeno analisador sintático. Vejamos como resolvemos esta questão, socorrendo-noas do módulo \texttt{cImage}.

\begin{lstlisting}
import cImage


def ppm_to_pil(imagem):
    # carrega ficheiro
    with open(imagem,'r') as ppm_img:
        # extrai cabeçalho (modo e comentário)
        ppm_img.readline()
        ppm_img.readline()
        # extrai dimensão
        dim = ppm_img.readline().split()
        largura = int(dim[0])
        altura = int(dim[1])
        # valor máximo de cor
        max_cor = ppm_img.readline()
        # cria imagem
        pil_img = cImage.EmptyImage(largura,altura)
        # converte
        for lin in range(altura):
            for col in range(largura):
                r = int(ppm_img.readline().rstrip('\n'))
                g = int(ppm_img.readline().rstrip('\n'))
                b = int(ppm_img.readline().rstrip('\n'))
                pixel = cImage.Pixel(r,g,b)
                pil_img.setPixel(col,lin,pixel)
    ppm_img.close()
    return pil_img

def mostra_ppm(imagem):
    """ Procede à diminiuição da pixelização da imagem."""  
    # carrega e Converte
    img = ppm_to_pil(imagem)
    # Cria janela
    largura = img.getWidth()
    altura = img.getHeight()    
    janela = cImage.ImageWin('PPM to PIL', largura, altura )
    # Salva imagem no disco
    nome_ficheiro  = imagem.split('.')[0] + '_to' + '.jpg'    
    img.save(nome_ficheiro)
    # Coloca imagem
    img.draw(janela)
    # Termina
    janela.exitOnClick() 
\end{lstlisting}

Sendo um ficheiro ASCII ele é aberto para leitura do modo convencional (linha 6). Depois, entre as linhas 7 e 15, lemos a informação que descreve o ficheiro, guardando apenas o que é relevante: a dimensão.

\subsubsection{De jpg para PPM}

O processo inverso, ou seja converter uma imagem \texttt{jpg}  para PPM ASCII, também não oferece muitas dúvidas e permite-nos rever algumas instruções envolvidas na criação de ficheiros de texto.

\begin{lstlisting}
def pil_to_ppm(imagem):
    """Constrói e salva uma imagem em formato PPM, modo ASCII."""
    # carrega ficheiro origem
    pil_img = cImage.FileImage(imagem)
    largura = pil_img.getWidth()
    altura = pil_img.getHeight()
    nome_completo = imagem.split('/')[-1]
    nome  = '/Users/ernestojfcosta/Desktop/' + nome_completo.split('.')[0] + '.ppm'
    ficheiro = open(nome,'w') 
    # constrói cabeçalho (modo, comentário, dimensão, cor máxima
    ficheiro.write('P3\n')
    ficheiro.write('# Criado por Ernesto Costa.\n')
    ficheiro.write(str(largura) + ' ' + str(altura) + '\n')
    ficheiro.write('255\n')
    # Guarda pixeis
    for lin in range(altura):
        for col in range(largura):
            pixel = pil_img.getPixel(col,lin)
            r = str(pixel.getRed()) + '\n'
            ficheiro.write(r)
            g = str(pixel.getGreen()) + '\n'
            ficheiro.write(g)   
            b = str(pixel.getBlue()) + '\n'
            ficheiro.write(b)                                   
    ficheiro.close()
    return ficheiro
\end{lstlisting}

Começamos por carregar o ficheiro fonte o extrair as suas dimensões (linhas 4 a 6). De seguida definimos o nome do novo ficheiro e abrimos para leitura (linhas 7 a 9).  Escrevemos de seguida o cabeçalho, isto é as cinco primeiras linhas que irão conter por esta ordem: o código \textbf{P3} que identifica o ficheiro como PPM ASCII, um comentário, a largura, a altura e o valor máximo da cor. Notar a necessidade de terminar cada linha por \texttt{\\n}. De seguida retiramos cada pixel da imagem original, obtemos os valores dos três canais e escrevemos eses valores em três linhas consecutivas. Este processo é repetido um número de vezes igual à dimensão da imagem (linhas 16 a 24).\\

Com esta interface podemos agora efectuar todas as manipulações anteriores com mais um formato de imagem!

\section*{Sumário}
\addcontentsline{toc}{section}{Sumário}

Neste capítulo introduzimos alguns conceitos sobre imagens, o modo como podem ser representadas e várias maneiras de as processar. Pusemos em relevo a existência de um padrão que envolve a travessia das imagens através de dois ciclos \texttt{for}. Discutimos ainda alguns aspectos de abstracção procedimental que se traduziu no uso de funções passadas como parâmetros. Introduzimos o módulo \texttt{cImage}, os seus tipos e operações. Criamos de seguida a nova imagem no formato pretendido (linha 17), por enquanto vazia. De seguida entramos num ciclo formado por dois \texttt{for} imbricados segundo uma lógica que já conhecemos. No interior do ciclo vamos buscar repetidamente sequências de três valores que formarão um pixel que iremos guardar na nova imagem (linhas 21 a 25). A função \texttt{mostra\_ppm} permite visualizar guardar a imagem no disco (linhas 38 e 39) e ainda visualizar  a imagem criada (linha 41).



\section*{Teste os seus conhecimentos}
\addcontentsline{toc}{section}{Teste os seus conhecimentos}

Verifique se conhece os conceitos discutidos neste capítulo e consegue responder às questões colocadas.

\begin{itemize}
\item O que entende por imagem \textit{bitmap}
\item O que entende por pixel?
\item O que entende por resolução de uma imagem?
\item O que entende por modo RGB?
\item A ordem e o modo de percorrer uma imagem são irrelevantes. Concorda com esta afirmação?
\item Quais as vantagens/inconvenientes  de usar o mecanismo de abstracção procedimental?
\item  O que entende por filtro ou máscara?
\item O que entende por convolução
\item O que entende por operadores de Sobel
\item Quanto maior for o filtro usado melhor se consegue o efeito pretendido. Concorda com esta afirmação?
\item Quando se usa um filtro, por que razão se cria uma nova imagem?
\end{itemize}


\section*{Exercícios}\footnote{Para não sobrecarregar  não indicaremos de forma explícita que se fará uso do módulo \texttt{cImage}.}
\addcontentsline{toc}{section}{Exercícios}

\begin{Exercicio}\facil

Desenvolva um programa que lhe permita mostrar os elementos que formam a matriz triangular inferior de uma da matriz à semelhança do que foi feito para o caso da matriz triangular superior. A listagem abaixo mostra o pretendido para a matriz
 \[mat = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\]

\begin{lstlisting}
1
5	6
9	10	11
\end{lstlisting}

\end{Exercicio}

\begin{Exercicio}\medio

Desenvolva um programa que lhe permita extrair uma sub-matriz de uma matriz dada, conhecido o elemento inicial e as dimensão da sub-matriz. Por exemplo, se chamarmos o programa com:

\begin{lstlisting}
print(sub_matriz([[1,2,3,4],[5,6,7,8],[9,10,11,12]],1,1,2,2))
\end{lstlisting}

o resultado obtido deverá ser:
\begin{lstlisting}
[[6, 7], [10, 11]]
\end{lstlisting}


\end{Exercicio}

\begin{Exercicio}\facil

Desenvolva um programa que lhe permita gerar uma matriz de tuplos em que cada tuplo contém possíveis valores de pixeis. Os parâmetros do programa são a  largura e a altura  da imagem.

\end{Exercicio}


\begin{Exercicio}\medio \label{exo:recta}

Desenvolva um programa que lhe permita desenhar uma linha recta numa janela, conhecidas as coordenadas de dois dos seus pontos. Relembramos que a equa\c cão de uma recta é dada por:
\[ y = \frac{y_{2} - y_{1}}{x_{2} - x_{1}} \times (x - x_{1}) + y_{1} \]

\end{Exercicio}

\begin{Exercicio}\medio

Desenvolva um programa que lhe permita desenhar um arco de circunferência com uma dada amplitude, conhecidos também as coordenadas do centro e o raio. Deve ser genérico: no limite deve permitir desenhar uma circunferência!

\end{Exercicio}

\begin{Exercicio}\facil

Pretende-se implementar um programa que permita adicionar uma moldura a uma imagem. Deve ser possível definir o tamanho da moldura e a sua cor. A figura \ref{fig:moldura} ilustra o pretendido.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{visoes_2/imagens/moldura.png}
\caption{Acrescentar uma moldura}
\label{fig:moldura}
\end{center}
\end{figure}

\end{Exercicio}

\begin{Exercicio}\facil

Implemente um programa que permita obter um corte de uma imagem. Para além da imagem devem ser fornecidos ao programa o ponto de início do corte e as dimensões. A figura \ref{fig:corte} ilustra a ideia pretendida.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{visoes_2/imagens/corta.png}
\caption{Corte de imagem}
\label{fig:corte}
\end{center}
\end{figure}

\end{Exercicio}

\begin{Exercicio}\medio

Discutimos um modelo para transformar toda uma imagem alterando um a um os seus pixeis de acordo com a mesma função de transformação. Vamos aplicar esse modelo ao caso da transformação de uma imagem a cores numa a \textbf{preto e branco}. A figura \ref{fig:pb} ilustra o pretendido. \textbf{Sugestão}: Para obter a imagem a preto e branco converta cada pixel para cinzento e depois compare com um limiar (por exemplo 128). Os maiores que o limiar são transformados em branco (ou seja (255,255,255))  e os menores ou igual em preto (ou seja em (0,0,0)).

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.7]{visoes_2/imagens/pb.png}
\caption{A preto e branco}
\label{fig:pb}
\end{center}
\end{figure}


\end{Exercicio}

\begin{Exercicio}\medio

Desenvolva um programa que lhe permita variar a intensidade dos pixeis de modo \textbf{independente}, isto é, a varia\c cão no vermelho, no verde e no azul pode ser diferente.

\end{Exercicio}


\begin{Exercicio}\dificil

Vimos um exemplo de como ampliar uma imagem, eventualmente com distorção. O problema agora é o inverso. Implementar um programa que permita reduzir uma imagem, uma vez mais com eventual distorção. A figura \ref{fig:reduc} ilustra o que se pretende.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{visoes_2/imagens/encolher.png}
\caption{Redução de uma imagem}
\label{fig:reduc}
\end{center}
\end{figure}
\end{Exercicio}

\begin{Exercicio}\medio

Vimos no texto como pegar na metade esquerda de uma imagem, criar uma cópia e juntar as duas partes como se fossem a imagem no espelho uma da outra. Pretende-se agora fazer algo semelhante, mas em que usamos a metade superior da imagem e o espelho é feito segunda uma perspectiva horizontal. A figura \ref{fig:esph} mostra o efeito pretendido.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{visoes_2/imagens/espelho_h.png}
\caption{Espelho horizontal}
\label{fig:esph}
\end{center}
\end{figure}


\end{Exercicio}

\begin{Exercicio}\medio

Muitas vezes acontece termos que reduzir as cores de uma imagem a um  número limitado de cores. O processo de redução passa por determinar para cada pixel qual a cor mais próxima de entre as cores disponíveis. Implemente o programa que lhe permite fazer essa transformação. Por exemplo, para a palete de cores:

\begin{lstlisting}
palete_cores = [(255,0,0), (0,255,0), (0,0,255), (0,0,0), (255,255,255), (255,255,0), (0,255,255), (255,0,255)] 
\end{lstlisting}

A execução do nosso programa para a imagem com os dois cães, que temos vindo a usar ao longo do capítulo, resulta no que a figura \ref{fig:reduz} ilustra.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{visoes_2/imagens/reduz.png}
\caption{Redução de cores}
\label{fig:reduz}
\end{center}
\end{figure}
\end{Exercicio}

\begin{Exercicio}\medio

Pretendemos desenvolver um programa que permita fazer uma colagem a partir de várias imagens. As imagens podem ter tamanhos diferentes, terem sido manipuladas para criar diversos efeitos, e ser colocadas em posições específicas da janela de visualização.

\end{Exercicio}

\begin{Exercicio}\medio\label{ex:blur}

Estudámos o problema de minimizar o efeito da pixelização. A nossa solução evita considerar o bordo da imagem o que se traduz por uma fina moldura de cor preta. Reveja o programa e altere-o por forma que tal não aconteça. A figura \ref{fig:blur2} mostra o resultado pretendido. \textbf{Sugestão}: no bordo calcule a média dos vizinhos existentes.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{visoes_2/imagens/blur_2.png}
\caption{Suavizar sem moldura}
\label{fig:blur2}
\end{center}
\end{figure}
\end{Exercicio}

\begin{Exercicio}\medio

Nas aulas falámos no conceito de Kernel (ou filtro, ou máscara) e mostrámos como o conceito podia ser usado para detectar os contornos de uma figura. Vamos agora explorar vários tipos de filtros. Fa\c ca uma pesquisa no \textbf{Google} pelas palavras \textbf{convolution} e \textbf{kernel} e descubra  filtros diferentes dos apresentados neste capítulo. Escolha as imagens do seu agrado e aplique  sobre  elas o respectivo filtro. Visualize o resultado.

\end{Exercicio}

\begin{Exercicio}\medio

Um modo de eliminar o ruído de uma fotografia consiste em considerar para cada pixel e cada canal a mediana dos valores do pixel e dos seus vizinhos. O cálculo da mediana faz-se ordenando os valores e considerando o que está na posição do meio. Implemente o respectivo programa.

\end{Exercicio}

\begin{Exercicio}\medio

Pretende-se um programa que permita pegar em duas imagens e fabricar uma terceira. Desenvolva o programa de forma modular de modo a controlar o processo que usa para combinar os pixeis das imagens. A título de exemplo, na imagem \ref{fig:funde} apresentamos uma combina\c cão entre Einstein e Gandhi.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.2]{visoes_2/imagens/funde_e_g_media.jpg}
\caption{{ Gandstein}}
\label{fig:funde}
\end{center}
\end{figure}


\end{Exercicio}

\begin{Exercicio}\dificil \label{exo:roda90}

Desenvolva um programa que dada uma imagem a roda de 90 graus. O sentido é à sua escolha.
\end{Exercicio}

\begin{Exercicio}\muitodificil

Neste exemplo pretendemos resolver uma questão semelhante à do exemplo \ref{exo:roda90}. Só que, agora, pretende-se que a rota\c cão possa ser de um ângulo arbitrário. \textbf{Nota:} A resolu\c cão desta questão obriga a saber algo sobre transla\c cão de sistemas de eixos, de trignometria e de álgebra.
\end{Exercicio}

\begin{Exercicio}\muitodificil
Muitas vezes queremos enviar imagens encriptadas. Para isso vamos criar um método que consiste em alterar a ordem das linhas da imagem original de modo aleatório. Quem receber a mensagem e conhecer o modo como se misturaram as linhas deve ser capaz de reconstruir a imagem original. Implemente os respectivos programas. A figura \ref{fig:encrip} ilustra o pretendido.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{visoes_2/imagens/encripta.png}
\caption{Encriptar uma imagem}
\label{fig:encrip}
\end{center}
\end{figure}
\end{Exercicio}

